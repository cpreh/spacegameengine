/**
\page audio audio

\section abstract Abstract

\em sge::audio provides an abstraction for 3D audio APIs like OpenAL or
DirectSound. It handles positional (and directional) sound sources, as well as
streaming sounds (for background music, for example). sge::audio also contains
audio file loaders.

\section overview Overview

\subsection loading File loading

\image html audio_pipeline.svg "The audio graph"

To play a sound, you have to create it first. Sounds may be procedurally
generated, meaning you have an algorithm producing waves which are then sent to
the sound card to process. In most cases, however, sounds are recorded, edited
and then saved to a <em>file</em>.

So to start, you need an audio file loader. sge has loaders for different
formats (wave, ogg, ...). Each loader is a plugin that can be loaded and then
used. Using the sge::audio::loader::load member function (or
sge::audio::loader::load_raw to load raw bytes), you get an sge::audio::file.

\subsection files Audio files

The sge::audio::file class has some information about the sound, like its bit
rate and number of channels. It also has functions to extract actual audio data
from the file. In most cases, however, we won't be needing these functions
directly. The audio API (OpenAL, Direct Sound etc.) will use them to extract
samples and, ultimately, send them to the sound card.

\subsection playback Playback

To actually <em>play</em> a sge::audio::file, you have to create a
<em>sound</em> from it. A sound object has functions like <code>gain</code> to
control its the volume, <code>play</code>, <code>stop</code> and so on (see
sge::audio::sound::base).

Until now, we only needed audio <em>loader</em> plugins. From this point on, we also
need an audio <em>player</em> plugin. An audio player can turn an
sge::audio::file into a sound. It also manages all of its sounds and can set
the global volume, speed of sound (used for Doppler calculations) and so on.

\subsection sounds Sounds

We want to create a sound, but not all sounds are created in the same way.
There are four different types of sounds:

<ol>
	<li><em>Positional, nonstreaming sounds</em>: Probably the most common
	type of sound. It has a position in the 3D space and it's loaded
	completely into memory. Think of short sound effects for your game (a
	pistol firing, an explosion). Background music is a <em>bad</em>
	example for this type of sound.</li>
	<li><em>Nonpositional, nonstreaming sounds</em>: These sounds have no
	position, but they are loaded into memory. A button click or a
	notification sound are good examples for this category.</li>
	<li><em>Nonpositional, streaming sounds</em>: The sound isn't read in
	completely, but in chunks. Background music.</li>
	<li><em>Positional, streaming sounds</em>: Should be pretty rare. A
	radio standing around playing music would be a good example for
	this.</li>
</ol>

\subsubsection nonstreaming Nonstreaming sounds

Let's focus on nonstreaming sounds, first. Say we want to spawn a
sound each time an explosion is displayed in a game. We have our
sge::audio::file object ready, which contains the samples of the explosion
sound. But we don't want to read this file each time an explosion occurs - the
nonstreaming sounds are supposed to be loaded <em>once</em> (loading also
implies conversions to some "internal" optimized format)!

\image html audio_buffers.svg "The buffer layer"

So there's a layer between the audio file and the sound (or "source", as
OpenAL terms it), called sge::audio::buffer. You'll see below on how to use it
exactly.

\subsubsection streaming Streaming sounds

Streaming sounds, on the other hand, don't need an intermediate layer. You can
directly create streaming sounds from your sge::audio::file. The audio
subsystem will keep the file pointer and extract samples from it when the
playback buffer empties.

\section example A first real example

\subsection Initialization

We have to initialize the loader(s) and the player plugins first. This can be
done manually or using the sge::systems::instance helper class.

\subsubsection systems_init sge::systems::instance initialization

Using sge::systems::instance, initialization of the player and the loaders is
very simple:

\snippet audio_minimal.cpp systems_initialization

You create an instance of the sge::systems::instance class and pass it a list
of things to initialize. To initialize the player, we pass it
sge::systems::audio_player_default. The player doesn't take any initialization
parameters.

Initializing the loader is slightly more complicated. That's because we have to
specify which file types we want to load. A loader indicates which file types
it is able to load by specifying a set of <em>file extensions</em>.

So the argument to sge::systems::instance is really a <em>request</em> for a
loader satisfying the constraints "can load .wav files".

\note
Don't be confused here: We're talking about <em>file</em> extensions and
loading wave <em>files</em>, but a loader can process raw bytes from a
different source, too (like a zip archive or from the internet). However, what
the sge::systems::instance class really creates is a sge::audio::multi_loader,
which is a <em>collection</em> of loaders. A multi loader takes a file name
and tries to figure out which loader is best for loading the file.  This is
where actual file extensions come into play. More on that later.

Notice that aside from the file extension, we pass an empty
sge::audio::loader_capabilities <a
href="http://fcppt.net/fcppt/documentation/container/bitfield/rationale.html">bitfield</a>,
too.
*/
