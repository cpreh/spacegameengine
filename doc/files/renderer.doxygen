/**
\page renderer renderer

\section abstract Abstract

sge::renderer provides an abstraction for 3D APIs, which currently is
mainly focused on the fixed function pipeline to guarantee maximum portability.
A glsl interface is also provided but can only be used with OpenGL.

\section vertices Vertices
The basic resource of a renderer are so called \em vertices, which are 3d
points with additional attributes like normals, texture coordinates, or even
user defined types. These vertices are used to define triangles, lines or
points, which are called \em primitives. The additional attributes can change
the way how primitives are rendered (for example, with texture coordinates,
texturing will be taken into account).

To actually store vertices on the graphics card, an
sge::renderer::vertex_buffer must be created. Internally, however, this buffer
is simply that, an array of bytes. To make filling data into the buffer easy,
sge implements an almost compile time safe layer on top of the buffers, so that
it is nearly as easy to use as an std::vector of structs. The structure of this
additional layer tells how the buffer is to be used (which attributes the
vertices have) and is therefore called a \em vertex \em format.

The vertex format can be used to create an sge::renderer::vertex_declaration
which is a runtime representation of it.

The distinction between the vertex_buffer and vertex_declaration classes is
necessary because different vertex attributes can be stored in different
vertex_buffers (for example the positions could go into one buffer and the
texture coordinates into another).

\subsection vertex_declarations Vertex declarations

sge offers certain classes that have to be used to declare the attributes of a
vertex.

In the following examples, the goal is to create a triangle with three
different colors for every vertex.

\image html renderer_colored_triangle.png "A triangle with three different vertex colors"

The colors are only defined for each vertex. The colors in between are
interpolated.

The first vertex attribute we declare is a position.  This is always needed if
you use the fixed function pipeline.

\snippet vertex.cpp position_declaration

This indicates that the vertex position should consist of three floats, which
are x, y and z, respectively.  Anything else is not really portable.  You can,
however, use double element types or positions with 2 or 4 coordinates with
OpenGL.

The next code snippet shows how to declare a color attribute.

\snippet vertex.cpp color_declaration

Here, a bgra8 color format is used that consists of 8 bits per color channel.

An sge::renderer::vf::part is a collection of vertex attributes that are to be
stored in a single vertex buffer.  Only one part is used in this example, so
both the position and the color go into it.

\snippet vertex.cpp format_part_declaration

The final thing to complete the vertex format is the format declaration that
tells of which parts the format will be made.

\snippet vertex.cpp format_declaration

The vertex_declaration is created from an sge::renderer::device, which is
available through sys.renderer() in this example.

\snippet vertex.cpp vertex_declaration

\subsection writing_vertices Writing Vertices

In order to fill a vertex_buffer, we first have to create one.  The
vertex_buffer has to be told which part of the vertex format it is going to
hold and which vertex declaration it belongs to.

\snippet vertex.cpp vertex_buffer

The vertex buffer consists of three elements, which are enough to create a
triangle from.

The next step is to get the vertex data into the buffer.

A renderer resource, such as a vertex buffer, cannot be read or written under
normal circumstances. To actually access its data, the resource must be \em
locked. Depending on the lock mode, the resource can be either read or written,
or both.  If you are done with reading or writing, the resource must be \em
unlocked again for the updates to actually take place.

In this example, we want to lock the whole vertex buffer for writing.  This is
done through an sge::renderer::scoped_vertex_lock that locks the vertex buffer
in its constructor and unlocks it in its destructor. We also put this into a
new block, so the destructor gets called when we desire (close the block).

\snippet vertex.cpp vblock_declaration

The final step is to connect the lock of the buffer with our vertex format
part. Therefore, we create an sge::renderer::vf::view on top of the buffer
lock.

\snippet vertex.cpp vertex_view_declaration

Here is why the extra layer is not completely compile time safe: If you mix a
vertex_buffer and a vertex format part that don't correspond to each other, you
will get an exception in the constructor of the vertex view.

The view provides begin and end methods which return iterators.

\snippet vertex.cpp vertex_iterator_declaration

Dereferencing these iterators yields a vertex structure whose attributes can be
accessed via the special classes that we typedeffed earlier.

\snippet vertex.cpp vertex_write_pos_1

In this example the pos3_type, that we typedeffed earlier, is used to access
the position of the vertex the iterator is pointing to. The type that has to be
used to write to the position is its packed_type. In this case, the packed_type
is a vector of three float elements.

The color is accessed in a similar fashion. The packed_type of the color is an
sge::image::color::bgra8. Here we use sge's predefined color cyan and convert
it to a bgra8 color.

\snippet vertex.cpp vertex_write_color_1

The rest of the vertices get written in a similar fashion.

\snippet vertex.cpp vertex_write_rest

We are done with the vertex lock and the scope is closed, so the buffer will be
unlocked.

\subsubsection drawing_vertices Drawing Vertices

To draw some of the vertices from the vertex buffer, we have to enable both the
vertex declaration and the vertex buffer using the renderer.  Therefore, we
create a new block that runs in a loop.

\snippet vertex.cpp running_block

sge::renderer::scoped_vertex_declaration sets the vertex declaration in its
constructor and unsets it in the destructor.
sge::renderer::scoped_vertex_buffer does the same but to a vertex buffer.

\snippet vertex.cpp scoped_declaration

Drawing can only be done between calls to
sge::renderer::device::begin_rendering and
sge::renderer::device::end_rendering.  An sge::renderer::scoped_block does this
in its constructor and destructor, respectively.

\snippet vertex.cpp scoped_block

We tell the renderer to draw the vertices 0 through 2 from the vertex buffer,
interpreting them as a list of triangles.

\section indices Indices

Recall that the supported primitive types are points, lines and triangles. If
we want to draw more complex, solid geometry, we have no choice but to build it
from triangles.
In the next example, the goal is to create a quad instead of a triangle
with four different colors for each corner.
Now, there are two ways to do that:

\li Create two separate triangles that don't share any vertices, resulting in
six vertices in total, duplicating two of the vertices.
\li Create only four vertices, one for each corner, and somehow tell the
renderer which combinations of them should become triangles.

For the latter to work, we can use \em indices. An index is a number that
refers to a vertex in a vertex buffer. It can go from 0 to vertex_count - 1.

\subsection index_format Index format

Like the vertex format, there also exists an \em index \em format. However, the
index format is much easier, because there currently are only two
possibilities: sge::renderer::index::format_16 and
sge::renderer::index::format_32. The number tells how many bits of storage an
index will take. So for example, with format_16 this limits the size of a
vertex buffer to 65535 elements.

In this example, we choose 16 bit indices.

\snippet vertex_index.cpp index_format_declaration

\subsection writing_indices Writing Indices

As with the vertex buffer, we have to create an index buffer to store the indices.

\snippet vertex_index.cpp index_buffer_declaration

The index buffer is locked in way similar to the vertex buffer.

\snippet vertex_index.cpp index_buffer_lock

Filling the indices into the buffer is also done via an iterator. Its value
type is sge::renderer::index::proxy which has a set member function. For the 16
bit format, the type accepted by the proxy is boost::uint16_t. In order to
assure that no implicit type conversions are done, only objects of this type
are accepted. In the example below, the static_cast is necessary to convert the
literals (which are of type int) into the expected value type.

\snippet vertex_index.cpp index_buffer_fill

\subsection rendering_indices Rendering indices

Instead of calling sge::renderer::device::render_nonindexed, the indexed
version will be used, which is sge::renderer::device::render_indexed.

\snippet vertex_index.cpp render_indexed

Here, we say that we want to draw two triangles, indicated by the primitive
count, and we need the first four vertices for this. Basically, first_vertex and
vertex_count set the limitations which values the indices can hold. To be most
conservative, 0 and vertex_buffer::size() should be used. first_index tells
where we start in the index buffer.

\section textures Textures

Instead of defining one color per vertex, which are then interpolated, we can
map an image onto a triangle. A resource that stores such an image is called a
\em texture.

Which portion of the texture is shown is determined by the \em texture \em
coordinates of each vertex. These are simply positions into a texture starting
from (0,0) at the top left to (1,1) at the bottom right.

Such a flat texture is called a \em planar \em texture.

There are two other texture types as well:

\li Volume Textures (3D textures)
\li Cube Textures (textures consisting of six planar textures, one for each side)

In the following example, a texture should be mapped onto our quad. Therefore,
we have to replace the vertex colors by texture coordinates.

\snippet vertex_texture.cpp texture_vf_declaration

sge::renderer::vf::texpos specifies the element type of a texture coordinate
(float is again most portable) and how many elements a texture coordinate
should have. We use two elements per coordinate here, as we have a flat image.

The next thing to change is how the vertices are written. We will specify
texture coordinates instead of vertex colors.

\snippet vertex_texture.cpp write_vertices

A texture is also needed. For this example, a grass texture is used.

\snippet vertex_texture.cpp load_texture

sge::renderer::texture::create_planar_from_path creates a planar texture
directly from an image file, using an image loader that is available through
sys.image_loader in this example.

To use our texture, we have to activate it. There are several texture stages,
which can be useful to blend different textures together. In this example,
however, we only need one texture, and therefore the 0th texture stage will be
used. Rendering will then use the activated texture.

\snippet vertex_texture.cpp render_block
*/
